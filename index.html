<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>To Scorpio: 星辰軌跡</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* 字体引入 */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Cormorant+Garamond:ital,wght@0,300;0,600;1,400&family=Noto+Serif+TC:wght@300;500;700&display=swap');

        :root {
            --color-deep-space: #050510;
            --color-star-glow: rgba(255, 255, 255, 0.8);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--color-deep-space);
            /* 全局基础字体设为思源宋体 */
            font-family: 'Noto Serif TC', serif; 
            color: #E0E0E0;
            user-select: none;
            -webkit-tap-highlight-color: transparent; /* 移除手机点击高亮 */
        }

        #canvas-bg {
            position: fixed;
            top: 0; left: 0;
            z-index: 0;
            pointer-events: auto; 
        }

        #game-ui {
            position: relative; z-index: 10;
            width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        
        #game-ui > * {
            pointer-events: auto;
        }

        /* 字体类 */
        .title-font { font-family: 'Cinzel', serif; letter-spacing: 0.2em; text-shadow: 0 0 20px rgba(224, 195, 252, 0.4); }
        .elegant-text { font-family: 'Cormorant Garamond', 'Noto Serif TC', serif; letter-spacing: 0.05em; }
        .tc-font { font-family: 'Noto Serif TC', serif; }

        /* 玻璃面板 */
        .glass-panel {
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            background: rgba(20, 20, 35, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            position: relative; overflow: hidden;
        }

        /* 玻璃罐子样式 - Stage 1 (立体感增强) */
        .glass-jar-container {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 160px; 
            height: 200px;
            z-index: 5;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .glass-jar {
            width: 100%;
            height: 100%;
            /* 更加丰富的玻璃质感 */
            background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.01) 50%, rgba(255,255,255,0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-top: none; 
            border-radius: 5px 5px 30px 30px; /* 底部更圆润 */
            backdrop-filter: blur(2px);
            /* 复杂的阴影模拟厚度和反光 */
            box-shadow: 
                inset 10px 0 20px rgba(255, 255, 255, 0.1), /* 左侧高光 */
                inset -10px 0 20px rgba(0, 0, 0, 0.2), /* 右侧阴影 */
                inset 0 -15px 30px rgba(0, 0, 0, 0.3), /* 底部厚度感 */
                0 15px 30px rgba(0, 0, 0, 0.5); /* 外部投影 */
            position: relative;
        }
        
        /* 罐口高光圈 */
        .glass-jar::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 15px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transform: translateY(-50%); 
        }

        /* 侧面反光条 */
        .glass-jar::after {
            content: '';
            position: absolute;
            top: 20px; left: 15px;
            width: 10px; height: 80%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.4), transparent);
            border-radius: 50px;
            filter: blur(2px);
            opacity: 0.6;
        }

        /* 按钮 */
        .star-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(224, 195, 252, 0.3);
            color: #e0c3fc;
            transition: all 0.5s cubic-bezier(0.22, 1, 0.36, 1);
            position: relative; overflow: hidden; font-family: 'Cinzel', serif;
            cursor: pointer;
        }
        .star-btn:hover {
            border-color: #fff; background: rgba(224, 195, 252, 0.15);
            text-shadow: 0 0 10px #e0c3fc; letter-spacing: 0.4em;
            box-shadow: 0 0 20px rgba(224, 195, 252, 0.2);
        }

        /* 动画类 */
        .hidden { display: none !important; }
        .fade-enter { opacity: 0; transform: translateY(20px); filter: blur(5px); }
        .fade-enter-active { opacity: 1; transform: translateY(0); filter: blur(0); transition: all 1.2s ease-out; }
        .fade-exit { opacity: 1; transform: scale(1); filter: blur(0); }
        .fade-exit-active { opacity: 0; transform: scale(1.1); filter: blur(10px); transition: all 0.8s ease-in; }

        /* Stage -1: Qzz 样式优化 */
        .qzz-char {
            position: absolute;
            font-size: 1.5rem; /* 调小字体 */
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Noto Serif TC', serif; /* 思源宋体 */
            cursor: pointer;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            animation: qzzFloat 3s ease-in-out infinite alternate;
            padding: 30px; /* 增大点击热区 */
            transition: color 0.3s;
        }
        .qzz-char:hover {
            color: #fff;
            text-shadow: 0 0 15px rgba(255, 255, 255, 1);
        }
        @keyframes qzzFloat {
            0% { transform: translateY(0) scale(1); opacity: 0.6; }
            100% { transform: translateY(-10px) scale(1.1); opacity: 1; }
        }

        .lucky-text {
            font-family: 'Noto Serif TC', serif;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4);
            font-size: 3rem;
            letter-spacing: 0.2em;
            opacity: 0;
            transform: scale(0.9);
            transition: all 1.5s ease-out;
            pointer-events: none;
        }

        /* Stage 1: Icons 优化 */
        .mem-icon {
            position: absolute;
            width: 50px; height: 50px;
            display: flex; align-items: center; justify-content: center;
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.4));
            cursor: pointer;
            will-change: transform, top, left, opacity;
            z-index: 20; /* Ensure clickable */
        }
        .mem-icon:hover { 
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.9)); 
            z-index: 50;
        }

        /* Stage 5: Heart Pulse */
        .heart-active {
            filter: drop-shadow(0 0 20px #ff4d6d) drop-shadow(0 0 40px #ff4d6d) !important;
            transform: scale(1.15) !important;
            color: #fff !important;
        }

        /* 拼图相关样式 (优化手机端) */
        .puzzle-slot {
            transition: background 0.3s, border-color 0.3s;
        }
        .puzzle-piece {
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .puzzle-piece.selected {
            box-shadow: 0 0 0 3px #ffd700, 0 0 20px #ffd700;
            transform: scale(1.1);
            z-index: 100;
        }

        /* Utility */
        #skip-arrow {
            position: fixed; bottom: 30px; right: 30px; z-index: 100;
            color: rgba(255, 255, 255, 0.3); font-size: 1.5rem; cursor: pointer;
            transition: all 0.3s; padding: 10px; border-radius: 50%; pointer-events: auto;
        }
        #skip-arrow:hover { color: rgba(255, 255, 255, 1); background: rgba(255,255,255,0.1); }
        
        input[type=range] { position: relative; z-index: 50; }

        /* 手机端竖屏优化媒体查询 */
        @media (max-width: 768px) {
            .title-font { font-size: 3rem !important; }
            .tc-font { font-size: 1rem !important; }
            .glass-jar-container { width: 120px; height: 160px; bottom: 15%; }
            #stage-0 { padding: 20px !important; margin: 20px; }
            /* 拼图区域竖屏排列 */
            .puzzle-layout { flex-direction: column !important; gap: 2rem !important; }
            #puzzle-pieces { grid-template-columns: repeat(4, 1fr) !important; width: 100% !important; gap: 0.5rem !important; }
            .puzzle-piece, .puzzle-slot { width: 70px !important; height: 70px !important; }
            #game-ui h2 { font-size: 2rem !important; }
        }
    </style>
</head>
<body>

    <canvas id="canvas-bg"></canvas>
    
    <!-- 背景音乐：使用Raw链接确保可流式播放 -->
    <audio id="bgm" loop>
        <source src="https://raw.githubusercontent.com/2314696760-cmd/-/e57360d2224230425344c337560828cfe43e6e76/28080737156-1-30232.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- 跳过按钮 -->
    <div id="skip-arrow" onclick="game.nextStage()" title="Next Step">
        <i class="fas fa-chevron-right"></i>
    </div>

    <div id="game-ui">
        
        <!-- Stage -1: Qzz Intro -->
        <div id="stage-pre" class="stage-container w-full h-full relative flex items-center justify-center">
            <div id="qzz-container" class="absolute inset-0 pointer-events-none"></div>
            <h1 id="lucky-msg" class="lucky-text absolute z-20 pointer-events-none">2026 Lucky</h1>
        </div>

        <!-- Stage 0: Title -->
        <div id="stage-0" class="stage-container hidden glass-panel text-center max-w-4xl p-16 mx-4">
            <div class="mb-12 relative group">
                <div class="absolute -inset-4 bg-gradient-to-r from-purple-900 to-red-900 rounded-full blur-xl opacity-20 group-hover:opacity-30 transition duration-1000"></div>
                <h1 class="relative text-6xl md:text-8xl mb-4 title-font text-white tracking-widest font-thin">CELESTIAL</h1>
                <div class="flex items-center justify-center gap-4 text-purple-200/60 mt-6">
                    <span class="h-[1px] w-12 bg-purple-200/30"></span>
                    <p class="text-sm tracking-[0.4em] uppercase font-light tc-font">Cancer & Scorpio</p>
                    <span class="h-[1px] w-12 bg-purple-200/30"></span>
                </div>
            </div>
            
            <p class="text-xl mb-16 text-gray-300 font-light leading-loose elegant-text italic">
                「在這片混沌的宇宙中，<br>
                我試圖尋找與妳引力重合的軌跡。」
            </p>
            
            <button onclick="audio.init(); game.nextStage();" class="star-btn px-12 py-4 text-sm font-bold rounded-sm tracking-[0.3em] uppercase">
                Start Journey
            </button>
        </div>

        <!-- Stage 1: Memory Icons & Jar -->
        <div id="stage-1" class="stage-container hidden w-full h-full relative">
            <div class="absolute top-16 w-full text-center pointer-events-none z-20">
                <h2 class="text-4xl title-font text-purple-100/90 mb-2">Collection</h2>
                <p class="tc-font text-lg text-purple-300/60 tracking-[0.5em]" id="stage1-text">存入罐子里的甜蜜 (0/11)</p>
            </div>
            
            <!-- 毛玻璃罐子 -->
            <div class="glass-jar-container" id="jar-target">
                <div class="glass-jar"></div>
            </div>
        </div>

        <!-- Stage 2: Orbit -->
        <div id="stage-2" class="stage-container hidden w-full h-full flex flex-col items-center justify-center">
             <div class="absolute top-16 text-center pointer-events-none z-20">
                <h2 class="text-4xl title-font text-blue-100/90 mb-2">Resonance</h2>
                <p class="tc-font text-lg text-blue-300/60 tracking-[0.5em]">引力同頻 · 心跳同步</p>
            </div>
            <div class="relative w-[90vw] h-[90vw] max-w-[600px] max-h-[600px] flex items-center justify-center pointer-events-none">
                <canvas id="orbit-canvas" width="600" height="600" class="z-10 w-full h-full"></canvas>
            </div>
            <div class="absolute bottom-24 w-80 glass-panel px-8 py-6 z-50">
                <input type="range" min="50" max="250" value="50" class="w-full cursor-pointer opacity-80 hover:opacity-100 transition-opacity accent-purple-400" id="orbit-slider">
            </div>
        </div>

        <!-- Stage 3: Big Dipper -->
        <div id="stage-3" class="stage-container hidden w-full h-full relative cursor-crosshair">
            <div class="absolute top-16 left-0 w-full text-center pointer-events-none z-30" id="st3-title">
                <h2 class="text-4xl title-font text-purple-100/90 mb-2">Guidance</h2>
                <p class="tc-font text-lg text-purple-300/60 tracking-[0.5em]">連結北斗 · 指引方向</p>
            </div>
            <canvas id="constellation-canvas" class="absolute top-0 left-0 w-full h-full z-20"></canvas>
        </div>

        <!-- Stage 4: Heart/Blackhole -->
        <div id="stage-4" class="stage-container hidden w-full h-full flex flex-col items-center justify-center relative overflow-hidden">
            <div class="absolute inset-0 bg-black/60 z-0"></div>
            <div class="z-20 text-center mb-24 pointer-events-none mix-blend-screen">
                <h2 class="text-5xl title-font text-red-700/80 tracking-widest mb-3">Heart</h2>
                <p class="tc-font text-lg text-red-900/60 tracking-[0.8em]">注入心意 · 點亮星核</p>
            </div>
            <div class="relative flex items-center justify-center group">
                <canvas id="heart-particle-canvas" width="600" height="600" class="absolute z-10 pointer-events-none"></canvas>
                <div id="blackhole-core" class="w-32 h-32 rounded-full bg-black shadow-[0_0_50px_rgba(100,0,0,0.3)] border border-red-900/30 z-20 relative transition-all duration-200 flex items-center justify-center">
                    <div class="w-full h-full rounded-full bg-red-900/20 opacity-0 transition-opacity duration-100" id="core-glow"></div>
                </div>
            </div>
            <button id="resist-btn" class="mt-32 w-28 h-28 rounded-full border border-white/10 bg-white/5 backdrop-blur-md shadow-[0_0_40px_rgba(255,255,255,0.05)] z-20 active:scale-95 transition-all flex items-center justify-center text-gray-300 font-serif text-lg tracking-[0.1em] select-none hover:bg-white/10 hover:text-white hover:border-white/30 cursor-pointer">
                Heart
            </button>
        </div>

        <!-- Stage 5: Rhythm -->
        <div id="stage-5" class="stage-container hidden w-full h-full flex flex-col items-center justify-center">
            <h2 class="text-4xl title-font text-red-100/90 mb-20 tracking-widest drop-shadow-[0_0_15px_rgba(255,50,50,0.3)]">Pulse</h2>
            <div class="relative w-96 h-96 flex items-center justify-center">
                <!-- Target Ring (Visual Aid only) -->
                <div id="heart-target" class="absolute w-full h-full border border-white/5 rounded-full scale-0 opacity-0"></div>
                
                <!-- Beat Button -->
                <div id="heart-beat" class="relative z-10 w-24 h-24 bg-gradient-to-t from-[#4a0e14] to-[#8a1c29] rounded-full shadow-[0_0_50px_rgba(138,28,41,0.5)] cursor-pointer flex items-center justify-center transition-transform active:scale-95 ring-1 ring-white/10">
                    <i class="fas fa-heart text-white/50 text-3xl transition-all duration-100" id="heart-icon"></i>
                </div>
            </div>
            <p class="mt-16 tc-font text-gray-500 text-sm tracking-[0.5em]">在愛心發光時觸碰 (0/5)</p>
        </div>

        <!-- Stage 6: Scratch -->
        <div id="stage-6" class="stage-container hidden w-full h-full flex flex-col items-center justify-center">
            <div class="absolute top-16 text-center pointer-events-none z-30">
                <h2 class="text-4xl title-font text-white/90 mb-2">Soul</h2>
                <p class="tc-font text-lg text-gray-400/50 tracking-[0.5em]">撥開迷霧 · 靈魂底色</p>
            </div>
            <div class="relative w-[340px] h-[480px] max-w-[90vw] p-3 glass-panel transform hover:scale-[1.02] transition-transform duration-700">
                <div class="absolute inset-0 m-3 bg-[#050510] flex items-center justify-center text-center p-8 border border-white/5">
                    <div>
                        <div class="text-6xl text-purple-500/20 mb-8 font-serif">❝</div>
                        <p class="elegant-text text-purple-100 text-xl leading-loose italic font-light">
                            In a world of monochrome,<br>
                            you are my<br>
                            <span class="text-transparent bg-clip-text bg-gradient-to-r from-purple-300 to-red-300 font-normal not-italic tracking-widest border-b border-purple-500/30 pb-1">Spectrum.</span>
                        </p>
                        <div class="text-6xl text-purple-500/20 mt-8 font-serif transform rotate-180">❝</div>
                    </div>
                </div>
                <canvas id="scratch-canvas" class="absolute inset-0 m-3 cursor-pointer touch-none z-10 mix-blend-hard-light"></canvas>
            </div>
        </div>

        <!-- Stage 7: Heat Scrub -->
        <div id="stage-7" class="stage-container hidden w-full h-full flex flex-col items-center justify-center">
            <h2 class="text-4xl title-font text-cyan-100/90 mb-16 pointer-events-none">Warmth</h2>
            <div class="relative w-80 h-80 group">
                <div class="absolute inset-0 flex items-center justify-center" id="shield-reveal">
                    <div class="text-center">
                        <div class="w-32 h-32 mx-auto mb-6 bg-gradient-to-tr from-gray-100 to-gray-400 rounded-full flex items-center justify-center shadow-[0_0_40px_rgba(255,255,255,0.2)]">
                             <i class="fas fa-shield-alt text-5xl text-gray-800"></i>
                        </div>
                        <p class="text-xs tracking-[0.4em] text-cyan-100 uppercase font-light">Guardian Activated</p>
                    </div>
                </div>
                <canvas id="heat-canvas" width="320" height="320" class="absolute inset-0 rounded-full z-10 shadow-[0_0_60px_rgba(0,255,255,0.1)]"></canvas>
                <p class="absolute -bottom-16 w-full text-center text-xs text-cyan-200/50 tracking-[0.3em] uppercase animate-pulse">Rub to melt the ice</p>
            </div>
        </div>

        <!-- Stage 8: Frequency -->
        <div id="stage-8" class="stage-container hidden w-full h-full flex flex-col items-center justify-center">
            <h2 class="text-4xl title-font text-emerald-100/90 mb-12">52.7 MHz</h2>
            <div class="glass-panel p-10 w-full max-w-xl mx-4">
                <div class="w-full h-48 border border-white/5 bg-[#050510]/60 rounded-sm relative mb-10 flex items-end overflow-hidden shadow-inner" id="wave-container">
                    <div class="absolute inset-0 grid grid-cols-6 gap-6 opacity-5 pointer-events-none">
                        <div class="border-r border-emerald-500"></div><div class="border-r border-emerald-500"></div><div class="border-r border-emerald-500"></div>
                        <div class="border-r border-emerald-500"></div><div class="border-r border-emerald-500"></div>
                    </div>
                    <canvas id="wave-canvas" class="w-full h-full relative z-10 opacity-90"></canvas>
                </div>
                <div class="flex items-center gap-6 px-4">
                    <span class="text-xs text-emerald-500/50 font-mono tracking-widest">40.0</span>
                    <input type="range" min="40" max="60" step="0.1" value="40" id="freq-slider" class="flex-1 accent-emerald-400 h-[2px] bg-white/10 rounded-lg appearance-none cursor-pointer hover:bg-white/20 transition-colors">
                    <span class="text-xs text-emerald-500/50 font-mono tracking-widest">60.0</span>
                </div>
                <div class="text-center mt-8 h-8">
                    <p id="freq-val" class="text-3xl font-mono text-emerald-300/90 tracking-[0.2em] font-light text-shadow-glow">40.0 <span class="text-xs opacity-50">MHz</span></p>
                </div>
            </div>
            <p id="freq-msg" class="mt-12 text-sm text-emerald-200/80 font-mono opacity-0 transition-opacity tracking-[0.5em] uppercase shadow-glow">Resonance Achieved</p>
        </div>

        <!-- Stage 9: Puzzle -->
        <div id="stage-9" class="stage-container hidden w-full h-full flex flex-col items-center justify-center">
            <h2 class="text-4xl title-font text-yellow-100/90 mb-8 pointer-events-none">Reunion</h2>
            <!-- Updated Layout for Mobile -->
            <div class="flex flex-col xl:flex-row gap-8 items-center justify-center puzzle-layout">
                <div class="grid grid-cols-3 gap-1 p-3 glass-panel" id="puzzle-area"></div>
                <!-- Mobile instructions -->
                <p class="xl:hidden text-xs text-gray-500 -my-4">點擊碎片，再點擊格子</p>
                <div class="grid grid-cols-4 gap-4 w-[400px]" id="puzzle-pieces"></div>
            </div>
        </div>

        <!-- Stage 10: Finale -->
        <div id="stage-10" class="stage-container hidden w-full h-full relative overflow-hidden">
            <div class="absolute bottom-0 w-full h-1/5 bg-black z-10 blur-[4px] opacity-80" style="clip-path: polygon(0% 100%, 5% 85%, 10% 90%, 15% 80%, 25% 95%, 35% 85%, 45% 90%, 55% 80%, 65% 95%, 75% 85%, 85% 90%, 95% 80%, 100% 100%);"></div>
            <div class="absolute bottom-32 left-0 right-0 z-20 text-center px-4">
                <h1 class="text-5xl md:text-6xl tc-font font-bold final-message mb-8 opacity-0 transition-opacity duration-3000 leading-tight text-white/90 drop-shadow-2xl" id="final-text">
                    今夜は月が綺麗ですね
                </h1>
                <p class="text-purple-200/80 text-3xl opacity-0 transition-opacity duration-3000 tracking-[0.3em] tc-font" id="sub-final-text">
                    2026馬年快樂
                </p>
            </div>
        </div>

    </div>

    <script>
        // --- 优化后的高品质音频引擎 (Web Audio API) ---
        // 使用 FM 合成和更复杂的包络模拟钢琴/空灵音色
        const audio = {
            ctx: null,
            bgmStarted: false,
            init() {
                if(!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if(this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
                // 启动背景音乐
                if (!this.bgmStarted) {
                    const bgmEl = document.getElementById('bgm');
                    bgmEl.volume = 0.4; // 设置BGM音量适中
                    bgmEl.play().catch(e => console.log("Auto-play prevented"));
                    this.bgmStarted = true;
                }
            },
            // 模拟钢琴/风铃般的空灵声音
            playPop() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                
                // 基础振荡器 (Sine) - 基音
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                // 泛音振荡器 (Triangle) - 增加金属/玻璃质感
                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();

                // 随机音高，选用五声音阶频率会让声音更悦耳 (C Major Pentatonic ish)
                const freqs = [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50];
                const freq = freqs[Math.floor(Math.random() * freqs.length)];

                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, t);
                
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(freq * 2, t); // 高八度泛音

                // 钢琴式包络：快速冲击，指数衰减
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.3, t + 0.02); // Attack
                gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5); // Long Decay

                gain2.gain.setValueAtTime(0, t);
                gain2.gain.linearRampToValueAtTime(0.1, t + 0.02);
                gain2.gain.exponentialRampToValueAtTime(0.001, t + 1.0); // Shorter decay for harmonics

                osc.connect(gain);
                osc2.connect(gain2);
                
                // 连接到总线
                gain.connect(this.ctx.destination);
                gain2.connect(this.ctx.destination);

                osc.start(t);
                osc.stop(t + 1.5);
                osc2.start(t);
                osc2.stop(t + 1.5);
            },
            // 粒子闪烁音效 (高频清脆)
            playSparkle() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200 + Math.random()*800, t);
                
                gain.gain.setValueAtTime(0.05, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(t); osc.stop(t + 0.2);
            },
            // 深沉的氛围音 (Glow)
            playGlow() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle'; // 稍微丰富的波形
                osc.frequency.setValueAtTime(110, t); // A2 低音
                
                // 缓慢的膨胀感
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.15, t + 0.5);
                gain.gain.linearRampToValueAtTime(0, t + 2.0);
                
                // 低通滤波让声音更温暖
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t); osc.stop(t + 2.0);
            },
            // 真实的烟花爆炸声 (White Noise + Low Pass Filter Sweep)
            playFirework() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                
                // 1. 爆炸主体 (The Thud) - 过滤后的白噪声
                const bufferSize = this.ctx.sampleRate * 2; // 2秒缓冲
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.setValueAtTime(800, t);
                noiseFilter.frequency.exponentialRampToValueAtTime(100, t + 0.3); // 频率快速下降模拟爆炸扩散

                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(1.0, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 1.0);

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.ctx.destination);
                noise.start(t);

                // 2. 噼啪声 (Crackle) - 随机的高频脉冲
                // 简单模拟：再加一层高通噪声
                const crackleGain = this.ctx.createGain();
                crackleGain.gain.setValueAtTime(0.2, t + 0.1);
                crackleGain.gain.linearRampToValueAtTime(0, t + 0.6);
                
                const crackleFilter = this.ctx.createBiquadFilter();
                crackleFilter.type = 'highpass';
                crackleFilter.frequency.value = 2000;

                const crackleSrc = this.ctx.createBufferSource();
                crackleSrc.buffer = buffer; // 复用噪声
                
                crackleSrc.connect(crackleFilter);
                crackleFilter.connect(crackleGain);
                crackleGain.connect(this.ctx.destination);
                crackleSrc.start(t);
            },
            // 成功和弦 (Major Chord) - 钢琴音色
            playSuccess() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                // C Major 7 chord: C, E, G, B
                const notes = [523.25, 659.25, 783.99, 987.77]; 
                
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle'; // 三角波比较接近电钢琴
                    osc.frequency.value = freq;
                    
                    // 琶音效果 (Arpeggio)
                    const start = t + i * 0.08;
                    
                    gain.gain.setValueAtTime(0, start);
                    gain.gain.linearRampToValueAtTime(0.2, start + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 3.0); // 长延音

                    osc.connect(gain); 
                    gain.connect(this.ctx.destination);
                    osc.start(start); 
                    osc.stop(start + 3.0);
                });
            }
        };

        // Core Setup
        const canvas = document.getElementById('canvas-bg');
        const ctx = canvas.getContext('2d');
        let width, height;
        let particles = [];
        let mouse = { x: -500, y: -500 };
        let fireworks = [];
        let jarParticles = []; // Particles inside the jar
        let currentStage = -1; // Start at Pre-stage
        let isTransitioning = false;
        let time = 0;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; createMouseParticles(); });
        window.addEventListener('touchmove', e => { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; createMouseParticles(); });

        // --- Visual Engine ---
        class Star {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = Math.random() * 1.5 + 0.2;
                this.baseAlpha = Math.random() * 0.6 + 0.1;
                this.alpha = this.baseAlpha;
                this.speed = Math.random() * 0.05 + 0.01;
                this.offset = Math.random() * 100;
            }
            update() {
                // 微弱漂浮
                this.x += Math.sin(time * 0.01 + this.offset) * 0.1;
                this.y += Math.cos(time * 0.01 + this.offset) * 0.1;
                
                // 微弱闪烁
                this.alpha = this.baseAlpha + Math.sin(time * 0.05 + this.offset) * 0.15;
                if(this.alpha < 0) this.alpha = 0;
                
                // 边界循环
                if(this.x < 0) this.x = width; if(this.x > width) this.x = 0;
                if(this.y < 0) this.y = height; if(this.y > height) this.y = 0;
            }
            draw() {
                // 确保星星也是普通混合模式，防止颜色污染
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = `rgba(255,255,255,${this.alpha})`;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
            }
        }
        class TrailParticle {
            constructor() {
                this.x = mouse.x; this.y = mouse.y;
                this.size = Math.random() * 2 + 1; // 稍微调小，增加细腻感
                this.life = 1; this.decay = 0.02;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = Math.random() * 1.5; // 稍微降低速度
                this.color = `224, 195, 252`; // 基础颜色
            }
            update() {
                this.x += Math.cos(this.angle)*this.speed; 
                this.y += Math.sin(this.angle)*this.speed;
                this.life -= this.decay;
                this.size *= 0.95; // 粒子逐渐变小
            }
            draw() {
                // 使用 lighter 混合模式制造发光感
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = `rgba(${this.color}, ${this.life * 0.6})`;
                
                // 添加辉光
                ctx.shadowBlur = 10;
                ctx.shadowColor = `rgba(${this.color}, ${this.life})`;
                
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                
                // 重置 shadowBlur，避免影响后续绘制性能
                ctx.shadowBlur = 0;
            }
        }
        
        // --- Helper for Shape Points ---
        function getShapePoints(type) {
            const points = [];
            if (type === 'Q') {
                // Circle
                for(let i=0; i<30; i++) {
                    const angle = (i/30) * Math.PI * 2;
                    points.push({x: Math.cos(angle)*0.8, y: Math.sin(angle)*0.8});
                }
                // Tail
                for(let i=0; i<10; i++) {
                     points.push({x: 0.3 + i*0.06, y: 0.3 + i*0.06});
                }
            } else if (type === 'Z') {
                // Top line
                for(let i=0; i<15; i++) points.push({x: -0.8 + i*0.11, y: -0.8});
                // Diagonal
                for(let i=0; i<20; i++) points.push({x: 0.8 - i*0.08, y: -0.8 + i*0.08});
                // Bottom line
                for(let i=0; i<15; i++) points.push({x: -0.8 + i*0.11, y: 0.8});
            }
            return points;
        }

        // Advanced Firework with Depth
        class Firework {
            constructor() {
                this.x = Math.random() * width * 0.8 + width*0.1;
                this.y = height;
                this.targetY = Math.random() * height * 0.5 + height * 0.1;
                this.vx = (Math.random()-0.5)*3;
                this.vy = -Math.random()*4 - 10;
                this.exploded = false;
                this.shards = [];
                // Randomly choose Q, Z or Standard(null)
                const rand = Math.random();
                if(rand < 0.3) this.shapeType = 'Q';
                else if(rand < 0.6) this.shapeType = 'Z';
                else this.shapeType = 'normal';
                
                this.hue = Math.random() * 360;
                // Add depth var
                this.z = Math.random() * 2 + 0.5; // Scale multiplier for depth
            }
            update() {
                if(!this.exploded) {
                    this.x += this.vx; this.y += this.vy; this.vy += 0.15;
                    if(this.vy >= 0 || this.y <= this.targetY) this.explode();
                } else {
                    this.shards.forEach((s,i) => {
                        s.x += s.vx; s.y += s.vy; s.vy += 0.05; 
                        s.life -= 0.015;
                        
                        // Flicker logic
                        if (Math.random() > 0.8) s.brightness = 1.5; // Flash bright
                        else s.brightness = 1;

                        if(s.life <= 0) this.shards.splice(i,1);
                    });
                }
            }
            explode() {
                this.exploded = true;
                audio.playFirework(); // Sound effect
                const baseSize = this.z; 

                if (this.shapeType !== 'normal') {
                    // Shape Explosion (Q or Z)
                    const points = getShapePoints(this.shapeType);
                    const scale = 80 * this.z; // Size of the letter in air
                    
                    points.forEach(p => {
                        // Add some jitter to make it look like organic firework
                        const jx = (Math.random()-0.5) * 10;
                        const jy = (Math.random()-0.5) * 10;
                        
                        this.shards.push({
                            x: this.x + p.x * scale * 0.1, // Start slightly clustered
                            y: this.y + p.y * scale * 0.1,
                            // Velocity aims towards the shape position to form it then expand
                            vx: p.x * 2 + (Math.random()-0.5)*0.5, 
                            vy: p.y * 2 + (Math.random()-0.5)*0.5,
                            life: 1.2, 
                            hue: this.hue,
                            size: (Math.random()*1.2 + 0.5) * baseSize, // Smaller particles
                            brightness: 1
                        });
                    });
                } else {
                    // Normal Explosion (Round & Random)
                    const count = 80 * this.z;
                    for(let i=0; i<count; i++) {
                        const angle = Math.random()*Math.PI*2;
                        const speed = Math.random()*5;
                        this.shards.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
                            life: 1, 
                            hue: this.hue + Math.random()*40,
                            size: (Math.random()*1.5 + 0.5) * baseSize, // Smaller particles
                            brightness: 1
                        });
                    }
                }
            }
            draw() {
                ctx.globalCompositeOperation = 'lighter'; // Key for glowing effect
                if(!this.exploded) {
                    ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                    ctx.beginPath(); ctx.arc(this.x, this.y, 1.5*this.z, 0, Math.PI*2); ctx.fill(); // Smaller trail head
                    // Trail
                    ctx.fillStyle = `rgba(255,255,255,0.1)`;
                    ctx.fillRect(this.x-0.5, this.y, 1*this.z, 10*this.z);
                } else {
                    this.shards.forEach(s => {
                        // Twinkling alpha
                        const alpha = s.life * (Math.random() * 0.5 + 0.5); 
                        
                        ctx.shadowBlur = s.brightness > 1 ? 10 : 0; // Only flash bright ones
                        ctx.shadowColor = `hsl(${s.hue}, 100%, 80%)`;
                        
                        ctx.fillStyle = `hsla(${s.hue}, 100%, ${70 * s.brightness}%, ${alpha})`;
                        ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
                        
                        ctx.shadowBlur = 0;
                    });
                }
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        const stars = Array(300).fill().map(() => new Star());
        function createMouseParticles() { if(Math.random()>0.5) particles.push(new TrailParticle()); }

        // Intro Particles specific
        let qzzParticles = [];
        class QzzParticle {
            constructor(x, y, targetX, targetY) {
                this.x = x; this.y = y;
                this.tx = targetX; this.ty = targetY;
                // Bezier control point for curved flight
                this.cx = (x + targetX) / 2 + (Math.random() - 0.5) * 100;
                this.cy = (y + targetY) / 2 + (Math.random() - 0.5) * 100;
                this.t = 0;
                this.speed = Math.random() * 0.02 + 0.01;
                this.arrived = false;
                this.size = Math.random() * 2 + 1;
            }
            update() {
                if(this.arrived) return;
                this.t += this.speed;
                if(this.t >= 1) {
                    this.t = 1;
                    this.arrived = true;
                }
                // Quadratic Bezier
                const invT = 1 - this.t;
                this.x = invT * invT * this.x + 2 * invT * this.t * this.cx + this.t * this.t * this.tx;
                this.y = invT * invT * this.y + 2 * invT * this.t * this.cy + this.t * this.t * this.ty;
            }
            draw() {
                if(this.arrived) return; // Disappear when arrived to reveal text
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = `rgba(255, 215, 0, ${1 - this.t + 0.2})`;
                ctx.shadowBlur = 10; ctx.shadowColor = 'gold';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // --- Jar Particle (Fixed Clipping with Masking) ---
        class JarParticle {
            constructor(startX, startY, targetX, targetY, color) {
                this.x = startX;
                this.y = startY;
                // Bezier control point (arc upwards)
                this.cx = (startX + targetX) / 2 + (Math.random() - 0.5) * 50;
                this.cy = Math.min(startY, targetY) - Math.random() * 200; // Arc high up
                this.tx = targetX;
                this.ty = targetY;
                this.t = 0;
                this.speed = Math.random() * 0.015 + 0.01;
                this.color = color;
                this.inJar = false;
                this.size = Math.random() * 2 + 1.5;
                // Wandering inside jar vars
                this.wSpeed = Math.random() * 0.01 + 0.005;
                this.wAngle = Math.random() * Math.PI * 2;
                
                // Keep target for wandering center reference
                this.centerX = targetX;
                this.centerY = targetY;
            }
            update() {
                if (!this.inJar) {
                    this.t += this.speed;
                    if (this.t >= 1) {
                        this.t = 1;
                        this.inJar = true;
                        this.x = this.tx; 
                        this.y = this.ty;
                        // Play small sparkle sound when entering jar occasionally
                        if(Math.random() > 0.8) audio.playSparkle();
                    } else {
                        // Quadratic Bezier movement
                        const invT = 1 - this.t;
                        this.x = invT * invT * this.x + 2 * invT * this.t * this.cx + this.t * this.t * this.tx;
                        this.y = invT * invT * this.y + 2 * invT * this.t * this.cy + this.t * this.t * this.ty;
                    }
                } else {
                    // Wander inside jar boundaries (Simulating Fireflies)
                    this.wAngle += (Math.random() - 0.5) * 0.2;
                    this.x += Math.cos(this.wAngle) * 0.5;
                    this.y += Math.sin(this.wAngle) * 0.5;
                    
                    // Bounce softly back to center if straying too far
                    const dx = this.x - this.centerX;
                    const dy = this.y - this.centerY;
                    if(Math.abs(dx) > 60) this.x -= dx*0.05;
                    if(Math.abs(dy) > 80) this.y -= dy*0.05;
                }
            }
            draw() {
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 8;
                ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Helper to draw Jar Path for Clipping (Dynamic for Mobile)
        function drawJarPath(ctx) {
            // Re-calculate dynamic positions to match CSS based on screen size
            const isMobile = width < 768;
            const jarW = isMobile ? 120 : 160;
            const jarH = isMobile ? 160 : 200;
            const jarX = width / 2; 
            // CSS: bottom: 10% (desktop) or 15% (mobile).
            const bottomMargin = height * (isMobile ? 0.15 : 0.10);
            const jarBottomY = height - bottomMargin;
            const jarTopY = jarBottomY - jarH;
            
            const left = jarX - jarW / 2;
            const right = jarX + jarW / 2;
            
            ctx.beginPath();
            ctx.moveTo(left, jarTopY);
            ctx.lineTo(right, jarTopY);
            ctx.lineTo(right, jarBottomY - 30); 
            ctx.quadraticCurveTo(right, jarBottomY, right - 30, jarBottomY);
            ctx.lineTo(left + 30, jarBottomY);
            ctx.quadraticCurveTo(left, jarBottomY, left, jarBottomY - 30);
            ctx.lineTo(left, jarTopY);
            ctx.closePath();
        }

        function loop() {
            time++;
            
            // --- CRITICAL FIX: Reset composite operation before clearing ---
            ctx.globalCompositeOperation = 'source-over'; 
            
            // Background Clearing
            ctx.fillStyle = 'rgba(5, 5, 16, 0.25)'; 
            ctx.fillRect(0, 0, width, height);

            stars.forEach(s => { s.update(); s.draw(); });
            particles.forEach((p,i) => {
                p.update(); p.draw();
                if(p.life<=0) particles.splice(i,1);
            });
            
            // Qzz Particles Logic
            if(currentStage === -1 && qzzParticles.length > 0) {
                qzzParticles.forEach(p => { p.update(); p.draw(); });
            }

            // Jar Particles Logic (Stage 1) - WITH MASKING
            if(currentStage === 1 && jarParticles.length > 0) {
                // 1. Draw flying particles (NOT in Jar) without clip
                jarParticles.forEach(p => { 
                    p.update(); 
                    if(!p.inJar) p.draw(); 
                });

                // 2. Draw IN-JAR particles WITH clip (Masking)
                ctx.save();
                drawJarPath(ctx);
                ctx.clip(); // Apply mask
                jarParticles.forEach(p => { 
                    if(p.inJar) p.draw(); 
                });
                ctx.restore(); // Remove mask
            }

            if(currentStage === 10) {
                if(Math.random()<0.08) fireworks.push(new Firework()); 
                fireworks.forEach((f,i) => {
                    f.update(); f.draw();
                    if(f.exploded && f.shards.length===0) fireworks.splice(i,1);
                });
            }
            requestAnimationFrame(loop);
        }
        loop();

        // --- Game Logic ---
        const game = {
            transition(curr, next) {
                if(isTransitioning) return;
                isTransitioning = true;
                const c = document.getElementById(curr === -1 ? 'stage-pre' : `stage-${curr}`);
                const n = document.getElementById(`stage-${next}`);
                
                audio.playGlow(); // Sound effect on transition

                if(c) {
                    c.classList.add('fade-exit-active');
                    setTimeout(() => c.classList.add('hidden'), 800);
                }
                
                setTimeout(() => {
                    n.classList.remove('hidden');
                    n.classList.add('fade-enter');
                    void n.offsetWidth;
                    n.classList.add('fade-enter-active');
                    setTimeout(() => {
                        n.classList.remove('fade-enter', 'fade-enter-active');
                        isTransitioning = false;
                    }, 1200);
                    this.initStage(next);
                }, 800);
                currentStage = next;
            },
            nextStage() { this.transition(currentStage, currentStage + 1); },
            initStage(id) {
                if(id===1) this.stage1();
                if(id===2) this.stage2();
                if(id===3) this.stage3();
                if(id===4) this.stage4();
                if(id===5) this.stage5();
                if(id===6) this.stage6();
                if(id===7) this.stage7();
                if(id===8) this.stage8();
                if(id===9) this.stage9();
                if(id===10) this.stage10();
            },

            // Pre-Intro: Qzz
            stagePre() {
                const container = document.getElementById('qzz-container');
                const msg = document.getElementById('lucky-msg');
                const chars = ['Q', 'z', 'z'];
                let clicked = 0;
                
                // Calculate center
                const cx = width / 2;
                const cy = height / 2;

                chars.forEach(char => {
                    const el = document.createElement('div');
                    el.className = 'qzz-char pointer-events-auto'; // Enable pointer events
                    el.innerText = char;
                    // Random positions, avoid exact center
                    el.style.left = Math.random() * 60 + 20 + '%';
                    el.style.top = Math.random() * 60 + 20 + '%';
                    
                    el.onclick = (e) => {
                        if(el.style.opacity === '0') return;
                        el.style.opacity = '0'; // Hide DOM element smoothly
                        el.style.pointerEvents = 'none';
                        audio.playPop(); // SFX

                        // Spawn canvas particles moving to center
                        const rect = el.getBoundingClientRect();
                        const startX = rect.left + rect.width/2;
                        const startY = rect.top + rect.height/2;

                        for(let i=0; i<40; i++) {
                            // Target is center of screen with slight spread
                            qzzParticles.push(new QzzParticle(
                                startX + (Math.random()-0.5)*30, 
                                startY + (Math.random()-0.5)*30, 
                                cx + (Math.random()-0.5)*150, 
                                cy + (Math.random()-0.5)*50
                            ));
                        }
                        
                        clicked++;
                        if(clicked === 3) {
                            setTimeout(() => {
                                qzzParticles = []; // Clear particles
                                msg.style.opacity = 1;
                                msg.style.transform = 'scale(1)';
                                setTimeout(() => game.nextStage(), 3500);
                            }, 1500); // Wait for particles to arrive roughly
                        }
                    };
                    container.appendChild(el);
                });
            },

            // Stage 1: Collection (Optimized)
            stage1() {
                // New Icon Set
                const items = [
                    { t:'t', v:'🍬', c:'#FF69B4' }, 
                    { t:'t', v:'🍰', c:'#FFFACD' }, 
                    { t:'t', v:'👠', c:'#00FFFF' }, 
                    { t:'t', v:'🌅', c:'#FF4500' }, 
                    { t:'t', v:'🌷', c:'#FF1493' }, 
                    { t:'t', v:'🌙', c:'#FFD700' }, 
                    { t:'i', v:'fa-cookie-bite', c:'#D2691E' }, 
                    { t:'t', v:'🌸', c:'#FFB7C5' }, 
                    { t:'i', v:'fa-cat', c:'#E0C3FC' }, 
                    { t:'t', v:'♋', c:'#6495ED' }, 
                    { t:'t', v:'♏', c:'#DC143C' }  
                ];
                
                let count = 0;
                const total = items.length;
                document.getElementById('stage1-text').innerText = `存入罐子里的甜蜜 (0/${total})`;
                
                items.forEach((item, i) => {
                    const el = document.createElement('div');
                    el.className = 'mem-icon absolute pointer-events-auto'; 
                    
                    // --- 1. 完全随机化布局 ---
                    const randX = Math.random() * 80 + 10; 
                    const randY = Math.random() * 50 + 15; // 偏上部分
                    
                    el.style.left = randX + '%'; 
                    el.style.top = randY + '%'; 
                    
                    const scale = Math.random() * 0.4 + 0.8;
                    const rotation = Math.random() * 30 - 15;
                    
                    el.style.transform = `scale(${scale}) rotate(${rotation}deg)`;

                    if(item.t === 'i') el.innerHTML = `<i class="fas ${item.v}" style="color:${item.c}"></i>`;
                    else el.innerHTML = `<span style="font-size:2rem;color:${item.c}">${item.v}</span>`;
                    
                    // --- 2. 独立的漂浮动画 ---
                    let floatTime = Math.random() * 100;
                    const floatSpeed = 0.02 + Math.random() * 0.02;
                    const floatRange = 10 + Math.random() * 10;
                    
                    function floatLoop() {
                        if(el.done) return;
                        floatTime += floatSpeed;
                        const offsetX = Math.sin(floatTime) * floatRange * 0.5;
                        const offsetY = Math.cos(floatTime * 0.8) * floatRange;
                        el.style.transform = `scale(${scale}) rotate(${rotation}deg) translate(${offsetX}px, ${offsetY}px)`;
                        requestAnimationFrame(floatLoop);
                    }
                    floatLoop();
                    
                    el.onclick = function() {
                        if(this.done) return; this.done = true;
                        audio.playPop(); // Sound

                        // Recalculate Jar visual center
                        const isMobile = width < 768;
                        const jarH = isMobile ? 160 : 200;
                        // CSS: bottom 10% (mobile 15%)
                        const bottomMargin = height * (isMobile ? 0.15 : 0.10);
                        const jarCenterY = height - bottomMargin - (jarH/2);
                        const jarCenterX = width / 2;
                        
                        // --- 3. 飞入罐子动画 ---
                        this.style.transition = 'all 1s cubic-bezier(0.5, 0, 0.5, 1)';
                        this.style.left = (jarCenterX - 25) + 'px'; 
                        this.style.top = (jarCenterY - 25) + 'px'; 
                        this.style.opacity = 0;
                        this.style.transform = `scale(0.2) rotate(${rotation + 720}deg)`; 
                        
                        const rect = this.getBoundingClientRect();
                        const startX = rect.left + rect.width/2;
                        const startY = rect.top + rect.height/2;

                        for(let k=0; k<7; k++) {
                            // Target is strictly jar area
                            jarParticles.push(new JarParticle(
                                startX, 
                                startY, 
                                jarCenterX + (Math.random()-0.5)*60, 
                                jarCenterY + (Math.random()-0.5)*80,
                                item.c 
                            ));
                        }
                        
                        count++;
                        document.getElementById('stage1-text').innerText = `存入罐子里的甜蜜 (${count}/${total})`;
                        if(count===total) setTimeout(() => {
                            audio.playSuccess();
                            game.nextStage();
                        }, 4000); 
                    }
                    document.getElementById('stage-1').appendChild(el);
                });
            },

            // Stage 3: Big Dipper (Modified coords for realism & offset)
            stage3() {
                const cvs = document.getElementById('constellation-canvas');
                cvs.width = width; cvs.height = height;
                const ctx = cvs.getContext('2d');
                // Realish Big Dipper coordinates (Approx)
                // 1. Alkaid (Handle tip)
                // 2. Mizar
                // 3. Alioth
                // 4. Megrez (Bowl connect)
                // 5. Phecda (Bowl bottom inner)
                // 6. Merak (Bowl bottom outer)
                // 7. Dubhe (Bowl top outer)
                const layout = [
                    {x:0.80, y:0.20}, // Alkaid
                    {x:0.72, y:0.24}, // Mizar
                    {x:0.65, y:0.27}, // Alioth
                    {x:0.58, y:0.35}, // Megrez
                    {x:0.59, y:0.50}, // Phecda
                    {x:0.45, y:0.52}, // Merak
                    {x:0.42, y:0.35}  // Dubhe
                ];
                
                // Add natural offset
                const stars = layout.map(p => ({
                    x: (p.x * width) + (Math.random()-0.5)*30, 
                    y: (p.y * height) + (Math.random()-0.5)*30,
                    active: false,
                    clicked: false
                }));
                
                function draw() {
                    if(currentStage !== 3) return;
                    ctx.clearRect(0,0,width,height);
                    
                    // Draw connections for active stars
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.lineWidth = 1;
                    
                    // Draw line logic: connect clicked stars
                    const connections = [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [3,6]];
                    connections.forEach(pair => {
                        if(stars[pair[0]].active && stars[pair[1]].active) {
                            ctx.moveTo(stars[pair[0]].x, stars[pair[0]].y);
                            ctx.lineTo(stars[pair[1]].x, stars[pair[1]].y);
                        }
                    });
                    ctx.stroke();

                    stars.forEach((s,i) => {
                        // Star
                        ctx.fillStyle = s.active ? '#fff' : 'rgba(255,255,255,0.3)';
                        ctx.beginPath(); ctx.arc(s.x, s.y, s.active?6:3, 0, Math.PI*2); ctx.fill();
                        
                        // Glow ring animation
                        if(s.active) {
                            ctx.shadowBlur = 20; ctx.shadowColor = '#fff';
                            ctx.beginPath(); ctx.arc(s.x, s.y, 6, 0, Math.PI*2); ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    });
                    requestAnimationFrame(draw);
                }
                draw();

                cvs.onclick = e => {
                    const rect = cvs.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    
                    let allActive = true;
                    let clickedOne = false;
                    stars.forEach(s => {
                        const dist = Math.sqrt((mx-s.x)**2 + (my-s.y)**2);
                        if(dist < 40 && !s.active) {
                            s.active = true; // Click to light up
                            clickedOne = true;
                        }
                        if(!s.active) allActive = false;
                    });
                    
                    if(clickedOne) audio.playPop();

                    if(allActive) {
                         setTimeout(() => {
                            document.getElementById('st3-title').style.opacity = 0;
                            cvs.style.transition = 'opacity 1s';
                            cvs.style.opacity = 0;
                            audio.playSuccess();
                            setTimeout(() => game.nextStage(), 1000);
                        }, 500);
                    }
                }
            },

            // Stage 4: Heart Press
            stage4() {
                const btn = document.getElementById('resist-btn');
                const core = document.getElementById('core-glow');
                const cvs = document.getElementById('heart-particle-canvas');
                const ctx = cvs.getContext('2d');
                let pressure = 0;
                let particles = [];
                let interval;

                function loop() {
                    if(currentStage !== 4) return;
                    ctx.clearRect(0,0,600,600);
                    
                    if(pressure > 0) {
                        for(let i=0; i<Math.floor(pressure/15); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const r = 250;
                            particles.push({
                                x: 300 + Math.cos(angle)*r, y: 300 + Math.sin(angle)*r,
                                vx: -Math.cos(angle)*4, vy: -Math.sin(angle)*4,
                                life: 50
                            });
                        }
                    }

                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                    particles.forEach((p, i) => {
                        p.x += p.vx; p.y += p.vy; p.life--;
                        ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
                        if(p.life<=0) particles.splice(i,1);
                    });
                    
                    requestAnimationFrame(loop);
                }
                loop();

                const down = () => {
                    audio.playGlow();
                    interval = setInterval(() => {
                        pressure = Math.min(pressure+1.5, 100);
                        core.style.opacity = pressure/100;
                        // Circle gets fuller
                        core.style.transform = `scale(${0.2 + pressure/120})`;
                        if(pressure >= 100) {
                            clearInterval(interval);
                            setTimeout(() => game.nextStage(), 1000);
                        }
                    }, 50);
                }
                const up = () => clearInterval(interval);
                
                btn.onmousedown = btn.ontouchstart = down;
                btn.onmouseup = btn.onmouseleave = btn.ontouchend = up;
            },

            // Stage 5: Rhythm
            stage5() {
                const target = document.getElementById('heart-target'); // Ring
                const beat = document.getElementById('heart-beat'); // Wrapper
                const icon = document.getElementById('heart-icon'); // Icon
                let hits = 0;
                let isGlowPhase = false;
                
                let start = Date.now();
                function anim() {
                    if(currentStage!==5) return;
                    // Period 2500ms - Slower pulse
                    const p = (Date.now() - start) % 2500 / 2500;
                    
                    // Ring expands
                    target.style.transform = `scale(${p * 1.5})`;
                    target.style.opacity = 1 - p;
                    
                    // Heart Glows Logic
                    if(p > 0.8 || p < 0.15) {
                        icon.classList.add('heart-active');
                        isGlowPhase = true;
                    } else {
                        icon.classList.remove('heart-active');
                        isGlowPhase = false;
                    }
                    requestAnimationFrame(anim);
                }
                anim();

                beat.onclick = () => {
                    if(isGlowPhase) {
                        hits++;
                        audio.playPop();
                        // Visual feedback
                        beat.style.boxShadow = `0 0 80px rgba(255, 50, 80, 0.8)`;
                        setTimeout(() => beat.style.boxShadow = `0 0 50px rgba(138,28,41,0.5)`, 300);
                        
                        if(hits===5) {
                            beat.innerHTML = '<i class="fas fa-check text-white text-3xl"></i>';
                            setTimeout(() => game.nextStage(), 1000);
                        }
                    }
                }
            },

            // Stage 6: Scratch
            stage6() {
                const sc = document.getElementById('scratch-canvas');
                const ctx = sc.getContext('2d');
                const container = sc.parentElement;
                sc.width = container.offsetWidth; sc.height = container.offsetHeight; 
                ctx.fillStyle = '#050510'; ctx.fillRect(0,0,sc.width, sc.height);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.font = "italic 300 20px 'Noto Serif TC'";
                ctx.textAlign = "center"; ctx.fillText("Rub to reveal", sc.width/2, sc.height/2);

                let completed = false; let pixels = 0; let isDown = false;
                const scratch = (x, y) => {
                    if(completed) return;
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath(); ctx.arc(x, y, 30, 0, Math.PI*2); ctx.fill();
                    pixels++;
                    if(pixels > 150 && !completed) {
                        completed = true;
                        audio.playSuccess();
                        sc.style.transition = 'opacity 1.5s ease'; sc.style.opacity = 0;
                        setTimeout(() => game.nextStage(), 3000);
                    }
                };
                const getPos = (e) => {
                    const r = sc.getBoundingClientRect();
                    const cx = e.touches ? e.touches[0].clientX : e.clientX;
                    const cy = e.touches ? e.touches[0].clientY : e.clientY;
                    return { x: cx - r.left, y: cy - r.top };
                };
                const down = () => isDown = true; const up = () => isDown = false;
                const move = (e) => { if(!isDown) return; e.preventDefault(); const p = getPos(e); scratch(p.x, p.y); };
                sc.onmousedown = sc.ontouchstart = down;
                window.onmouseup = window.ontouchend = up;
                sc.onmousemove = sc.ontouchmove = move;
            },

            // Stage 7: Heat
            stage7() {
                const hCvs = document.getElementById('heat-canvas');
                const ctx = hCvs.getContext('2d');
                ctx.fillStyle = 'rgba(200, 240, 255, 0.9)'; ctx.fillRect(0,0,320,320);
                let isDrawing = false; let melted = 0;
                function melt(x, y) {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath(); ctx.arc(x, y, 20, 0, Math.PI*2); ctx.fill();
                    melted++;
                    if(melted > 150) { 
                        hCvs.style.opacity = 0; hCvs.style.transition = 'opacity 1s';
                        document.getElementById('shield-reveal').style.opacity = 1;
                        audio.playSuccess();
                        setTimeout(() => game.nextStage(), 2000);
                    }
                }
                hCvs.onmousedown = () => isDrawing = true; window.onmouseup = () => isDrawing = false;
                hCvs.onmousemove = e => { if(!isDrawing) return; const r = hCvs.getBoundingClientRect(); melt(e.clientX - r.left, e.clientY - r.top); }
                hCvs.ontouchstart = (e) => { isDrawing = true; e.preventDefault(); }
                window.ontouchend = () => isDrawing = false;
                hCvs.ontouchmove = (e) => { if(!isDrawing) return; const r = hCvs.getBoundingClientRect(); melt(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top); }
            },

            // Stage 8: Frequency
            stage8() {
                const cvs = document.getElementById('wave-canvas');
                const ctx = cvs.getContext('2d');
                const slider = document.getElementById('freq-slider');
                const valDisp = document.getElementById('freq-val');
                const TARGET = 52.7;
                let waveT = 0;
                function draw() {
                    if(currentStage !== 8) return;
                    cvs.width = cvs.offsetWidth; cvs.height = cvs.offsetHeight;
                    const w = cvs.width, h = cvs.height;
                    ctx.clearRect(0,0,w,h);
                    const userVal = parseFloat(slider.value);
                    ctx.beginPath(); ctx.strokeStyle = 'rgba(100,100,100,0.5)'; ctx.lineWidth = 2;
                    for(let x=0; x<w; x++) ctx.lineTo(x, h/2 + Math.sin(x*0.05 + waveT)*30);
                    ctx.stroke();
                    const freqDiff = (userVal - TARGET) / 10; 
                    const freq = 0.05 + freqDiff; 
                    const isMatch = Math.abs(userVal - TARGET) < 0.2;
                    ctx.beginPath(); ctx.strokeStyle = isMatch ? '#00ffaa' : '#00aa55'; ctx.lineWidth = isMatch ? 4 : 2;
                    if(isMatch) {
                        ctx.shadowBlur = 20; ctx.shadowColor = '#00ffaa';
                        for(let x=0; x<w; x++) ctx.lineTo(x, h/2 + Math.sin(x*0.05 + waveT)*30);
                    } else {
                        ctx.shadowBlur = 0;
                        for(let x=0; x<w; x++) ctx.lineTo(x, h/2 + Math.sin(x*freq + waveT)*30);
                    }
                    ctx.stroke();
                    if(isMatch) { document.getElementById('freq-msg').style.opacity = 1; audio.playSuccess(); setTimeout(() => game.nextStage(), 2000); } 
                    else { document.getElementById('freq-msg').style.opacity = 0; }
                    waveT += 0.2; requestAnimationFrame(draw);
                }
                draw();
                slider.oninput = e => valDisp.innerHTML = parseFloat(e.target.value).toFixed(1) + ' <span class="text-xs">MHz</span>';
            },

            // Stage 9: Puzzle (Refactored for Mobile Touch)
            stage9() {
                const area = document.getElementById('puzzle-area');
                const src = document.getElementById('puzzle-pieces');
                const IMG = "微信图片_20251104183046_51_782.jpg";
                const FALLBACK = "https://images.unsplash.com/photo-1534447677768-be436bb09401?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80";
                const bg = `url('${IMG}'), url('${FALLBACK}')`;
                let matches = 0;
                let selectedPiece = null;

                // Create Drop Slots
                for(let i=0; i<12; i++) {
                    const d = document.createElement('div');
                    d.className = 'puzzle-slot w-24 h-24 border border-dashed border-white/20 bg-white/5 flex items-center justify-center cursor-pointer';
                    d.dataset.index = i;
                    
                    // Click to Place (Mobile Friendly)
                    d.onclick = () => {
                        if(selectedPiece && !d.classList.contains('filled')) {
                            const pieceId = parseInt(selectedPiece.dataset.index);
                            if(pieceId === i) {
                                // Match!
                                d.style.backgroundImage = bg;
                                d.style.backgroundPosition = selectedPiece.style.backgroundPosition;
                                d.style.backgroundSize = "300% 400%"; d.style.border = "none";
                                d.classList.add('filled');
                                
                                selectedPiece.style.display = 'none';
                                selectedPiece = null;
                                
                                audio.playPop(); // Correct placement sound
                                matches++;
                                if(matches===12) {
                                    audio.playSuccess();
                                    setTimeout(()=>game.nextStage(), 1500);
                                }
                            } else {
                                // Wrong placement visual shake?
                                d.style.borderColor = 'red';
                                setTimeout(() => d.style.borderColor = 'rgba(255,255,255,0.2)', 300);
                            }
                        }
                    };
                    
                    // Drag Over (Desktop)
                    d.ondragover = e => e.preventDefault();
                    d.ondrop = e => {
                        const id = e.dataTransfer.getData('id');
                        if(id == i) {
                            d.onclick(); // Trigger logic
                        }
                    }
                    area.appendChild(d);
                }

                // Create Pieces
                const idxs = [...Array(12).keys()].sort(()=>Math.random()-0.5);
                idxs.forEach(i => {
                    const p = document.createElement('div');
                    p.id = 'p-'+i; p.draggable = true;
                    p.dataset.index = i;
                    p.className = 'puzzle-piece w-24 h-24 bg-cover cursor-pointer border border-white/30';
                    p.style.backgroundImage = bg; p.style.backgroundSize = "300% 400%";
                    p.style.backgroundPosition = `${(i%3)*50}% ${(Math.floor(i/3))*33.3}%`;
                    
                    // Click to Select (Mobile)
                    p.onclick = () => {
                        // Deselect others
                        document.querySelectorAll('.puzzle-piece').forEach(el => el.classList.remove('selected'));
                        
                        if(selectedPiece === p) {
                            selectedPiece = null; // Toggle off
                        } else {
                            p.classList.add('selected');
                            selectedPiece = p;
                            audio.playSparkle(); // Selection sound
                        }
                    };

                    // Drag Start (Desktop)
                    p.ondragstart = e => {
                        e.dataTransfer.setData('id', i);
                        selectedPiece = p; // Sync logic
                    };
                    src.appendChild(p);
                });
            },

            // Stage 10: Finale
            stage10() {
                setTimeout(() => document.getElementById('final-text').style.opacity = 1, 1000);
                setTimeout(() => document.getElementById('sub-final-text').style.opacity = 1, 3000);
            },

            start() { this.stagePre(); }
        };

        game.start();
        game.stage2 = function() {
            const cvs = document.getElementById('orbit-canvas'); const ctx = cvs.getContext('2d');
            const slider = document.getElementById('orbit-slider');
            let a1=0, a2=Math.PI;
            function loop() {
                if(currentStage!==2) return;
                // Resize handling inside loop for this stage to be safe
                cvs.width = cvs.offsetWidth; cvs.height = cvs.offsetHeight;
                const w = cvs.width, h = cvs.height;
                const cx = w/2, cy = h/2;
                
                ctx.clearRect(0,0,w,h);
                const r1= w * 0.25; 
                const baseR2 = parseInt(slider.value); // 50-250 range
                // Scale r2 relative to screen size roughly
                const r2 = (baseR2 / 300) * w;

                ctx.strokeStyle='rgba(255,255,255,0.1)'; ctx.beginPath(); ctx.arc(cx,cy,r1,0,7); ctx.stroke();
                ctx.strokeStyle='rgba(100,150,255,0.3)'; ctx.beginPath(); ctx.arc(cx,cy,r2,0,7); ctx.stroke();
                a1+=0.02; a2+=0.025;
                ctx.fillStyle='#8a1c29'; ctx.beginPath(); ctx.arc(cx+Math.cos(a1)*r1, cy+Math.sin(a1)*r1, 8,0,7); ctx.fill();
                ctx.fillStyle='#3d5afe'; ctx.beginPath(); ctx.arc(cx+Math.cos(a2)*r2, cy+Math.sin(a2)*r2, 8,0,7); ctx.fill();
                
                // Check win condition (normalized distance)
                if(Math.abs(r1-r2) < w*0.05) { 
                    audio.playSuccess();
                    setTimeout(()=>game.nextStage(),1000); 
                }
                requestAnimationFrame(loop);
            }
            loop();
        }
    </script>
</body>
</html>
